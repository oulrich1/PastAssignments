
/*  // GPL.L
 *   Lexical scanner. scans for tokens that are used in GPL.
 *  
 *         (BISON uses tokens generated from this file to match 
 *          grammer and take specific actions) (see gpl.y)
 *
*
 */

/*
	 Use the following global variable to retrieve the current symbol (the one
	 just read):

	 char *yytext               //

	 Use the following global variable to send information back to main():

	 extern YYSTYPE yylval;

	 The union YYSTYPE is defined in y.tab.h (which is included by parser.h).
	 You can use a union just like a struct (which is a lot like a class),
	 except that only one member variable can be used at a time.
	 y.tab.h is generated by bison from expr.y.

 */

%{

#include "error.h"    // GPL specific error funcs()
#include "parser.h"   

#include <ctype.h>
#include <iostream>
	using namespace std;

	Error error_handler; // error reporting object

	// The following variable keeps track of what input line flex is reading.
	// It will be used (by other parts of the program) for reporting the line
	// numbers of errors.
	// It will be used by other parts of the program via the extern construct
	//   If another .cpp file declares "extern int line_count" that line_count
	//   in that file will be the line_count in this file (it becomes global)
	int line_count = 1;

	int 
	emit_int(int token)
	{
		// convert the string yytext into an integer
		// put it into the global union used to send values to the parser (.y file)
		// the union is declared in the .y file
		yylval.union_int = atoi(yytext);

		return token;
	}

	// **********************************************************************
	// sets the union_double to the double that yytext contains 
	//   since yytext was matched with expression and this func is called
	//   returns token that bison needs in order to know that a double value was read
	int 
	emit_double(int token){
		// matched "text" needs to be converted to double in order to do calc
		yylval.union_double = atof(yytext); // value union's "double" is set to the input
		return token;
	}


	// ********************************************************************** 
	// when string is matched this is called and sets A NEW string appropriately.
	// an accompanying token is returned.
	int 
	emit_string(int token){
		yylval.union_string = new string(yytext+1, strlen(yytext)-2);
		return token;
	}



	// ********************************************************************** 
	// stores the identifier name for a variable (ASSOCIATED WITH T_ID)
	int
	emit_identifier(int token){
		yylval.union_string = new string(yytext, strlen(yytext));
		return token;
	}

	int 
	emit_error(int token)
	{
		// have the error handling object report the problem
		// note: it uses line_count as a global variable
		error_handler.error(Error::ILLEGAL_TOKEN, yytext);

		// create a string to hold the current text
		// put that string in the yylval union so it can be used by parser (.y file)
		yylval.union_string = new string(yytext);
		return token;
	}


	int
	emit_with_line_number(int token){
		 yylval.union_int = line_count;
	   return token;
	}
	
%}


%%

[\n]										line_count++; // count the lines for error reporting
[ \t\r]									;  // ignore spaces, tabs and the line feed (\r)

"//".*\n							  line_count++;  // ignore ocmments  

 



"int"											                  return(T_INT);         //objects
"double"															           return(T_DOUBLE);	
"string"										                return(T_STRING);						
"triangle"															         return(T_TRIANGLE);	
"pixmap"															           return(T_PIXMAP);	
"circle"															           return(T_CIRCLE);	
"rectangle"															        return(T_RECTANGLE);	
"textbox"															          return(T_TEXTBOX);	
						
"forward"															          return(T_FORWARD);  // keywords
"initialization"															   return(T_INITIALIZATION);	
"on"															               return(T_ON);	
"animation"															        return(T_ANIMATION);	
"if"															               return(T_IF);	
"for"															              return(T_FOR);	
"else"															             return(T_ELSE);	
"exit"															            return emit_with_line_number(T_EXIT);	
"print"															            return emit_with_line_number(T_PRINT);	
"true"															             return(T_TRUE);	
"false"						                     					return(T_FALSE);  // const values set in bison 

"space"														             return(T_SPACE); // event keys
"leftarrow"															        return(T_LEFTARROW );	
"rightarrow"															       return(T_RIGHTARROW );	
"uparrow"															          return(T_UPARROW );	
"downarrow"															        return(T_DOWNARROW );	
"leftmouse_down"															   return(T_LEFTMOUSE_DOWN );	
"middlemouse_down"															 return(T_MIDDLEMOUSE_DOWN );	
"rightmouse_down"															  return(T_RIGHTMOUSE_DOWN );	
"leftmouse_up"															     return(T_LEFTMOUSE_UP );	
"middlemouse_up"															   return(T_MIDDLEMOUSE_UP );	
"rightmouse_up"															    return(T_RIGHTMOUSE_UP );	
"mouse_move"															       return(T_MOUSE_MOVE );	
"mouse_drag"															       return(T_MOUSE_DRAG );	
"f1"															               return(T_F1 );	
"akey"															             return(T_AKEY );	
"skey"															             return(T_SKEY );	
"dkey"															             return(T_DKEY );	
"fkey"															             return(T_FKEY );	
"hkey"															             return(T_HKEY );	
"jkey"															             return(T_JKEY );	
"kkey"															             return(T_KKEY );	
"lkey"															             return(T_LKEY );	
"wkey"															             return(T_WKEY );	

"("													                  return(T_LPAREN ); 
")"																               return(T_RPAREN);	
"{"																               return(T_LBRACE);	
"}"																               return(T_RBRACE);	
"["															                return(T_LBRACKET);	
"]"															                return(T_RBRACKET);	
";"																               return(T_SEMIC);	
","																               return(T_COMMA);	
"."																               return(T_PERIOD);	
						
"="														                 return(T_ASSIGN); 
"+="															               return(T_PLUS_ASSIGN);	
"-="															               return(T_MINUS_ASSIGN);	
						
"sin"																		           return(T_SIN ); 
"cos"															              return(T_COS );	
"tan"															              return(T_TAN );	
"asin"															             return(T_ASIN );	
"acos"															             return(T_ACOS );	
"atan"															             return(T_ATAN );	
"sqrt"															             return(T_SQRT );	
"abs"															              return(T_ABS );	
"floor"															            return(T_FLOOR );	
"random"															           return(T_RANDOM );	
						
"touches"											              return(T_TOUCHES );
"near"															             return(T_NEAR );	
						

"*"										                     return(T_ASTERISK); 
"/"																               return(T_DIVIDE);	
"+"																               return(T_PLUS);	
"-"																               return(T_MINUS);	
"%"																               return(T_MOD);	
						

"<"																               return(T_LESS); 
">"																               return(T_GREATER);	
"<="															               return(T_LESS_EQUAL);	
">="															               return(T_GREATER_EQUAL);	
"=="															               return(T_EQUAL);	
"!="															               return(T_NOT_EQUAL);	
"!"															                return(T_NOT);	
"&&"															               return(T_AND);	
"||"															               return(T_OR);	


[0-9]+									 				return emit_int(T_INT_CONSTANT);
[0-9]+\.[0-9]*|\.[0-9]+  				return emit_double(T_DOUBLE_CONSTANT); 
\"\"													{ return emit_string(T_STRING_CONSTANT);} // empty string
\"[^\"\\]*\"                  { return emit_string(T_STRING_CONSTANT);} // a string
[a-zA-Z_]+[a-z0-9A-Z_]* 		  { return emit_identifier(T_ID);}          // a variable.. 
 
.                                 {}; // ignore the rest.. else it just prints out  "'s everywhere...


